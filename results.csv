agent,algorithm,status,patch,metrics_before,metrics_after,error_message
ArcaneAgent,bitcount,PASS,"def bitcount(n: int) -> int:
    if not isinstance(n, int) or n < 0:
        raise ValueError(""Input must be a nonnegative integer."")
    return n.bit_count()

""""""
Bitcount
bitcount

Input:
    n: a nonnegative int

Output:
    The number of 1-bits in the binary encoding of n

Examples:
    >>> bitcount(127)
    7
    >>> bitcount(128)
    1
""""""",,,
BaselineAware,bitcount,PASS,"def bitcount(n: int) -> int:
    if not isinstance(n, int) or n < 0:
        raise ValueError(""Input must be a nonnegative integer."")
    return n.bit_count()

""""""
Bitcount
bitcount

Input:
    n: a nonnegative int

Output:
    The number of 1-bits in the binary encoding of n

Examples:
    >>> bitcount(127)
    7
    >>> bitcount(128)
    1
""""""",,,
BaselineNaive,bitcount,PASS,"def bitcount(n):
    return bin(n).count('1')

""""""
Bitcount
bitcount

Input:
    n: a nonnegative int

Output:
    The number of 1-bits in the binary encoding of n

Examples:
    >>> bitcount(127)
    7
    >>> bitcount(128)
    1
""""""",,,
ArcaneAgent,bucketsort,PASS,"def count_occurrences(arr, k):
    counts = [0] * k
    for x in arr:
        counts[x] += 1
    return counts

def build_sorted_array(counts):
    sorted_arr = []
    for number, count in enumerate(counts):
        sorted_arr.extend([number] * count)
    return sorted_arr

def bucketsort(arr, k):
    counts = count_occurrences(arr, k)
    return build_sorted_array(counts)

# Example usage
if __name__ == ""__main__"":
    arr = [3, 1, 2, 1, 4]
    k = 5
    sorted_arr = bucketsort(arr, k)
    print(""Sorted array:"", sorted_arr)",,,
BaselineAware,bucketsort,PASS,"def bucketsort(arr, k):
    # Validate input
    if not all(isinstance(x, int) and 0 <= x < k for x in arr):
        raise ValueError(""All elements must be integers in the range [0, k)"")

    # Count occurrences of each integer
    counts = [0] * k
    for x in arr:
        counts[x] += 1

    # Create the sorted array
    sorted_arr = []
    for i, count in enumerate(counts):
        sorted_arr.extend([i] * count)

    return sorted_arr

# Example usage
if __name__ == ""__main__"":
    arr = [3, 1, 2, 1, 4, 3, 0]
    k = 5
    print(bucketsort(arr, k))",,,
BaselineNaive,bucketsort,PASS,"def bucketsort(arr, k):
    counts = [0] * k
    for x in arr:
        counts[x] += 1

    sorted_arr = []
    for i, count in enumerate(counts):  # Corrected from 'arr' to 'counts'
        sorted_arr.extend([i] * count)

    return sorted_arr



""""""
Bucket Sort


Input:
    arr: A list of small ints
    k: Upper bound of the size of the ints in arr (not inclusive)

Precondition:
    all(isinstance(x, int) and 0 <= x < k for x in arr)

Output:
    The elements of arr in sorted order
""""""",,,
ArcaneAgent,find_first_in_sorted,PASS,"import bisect

def find_first_in_sorted(arr, x):
    index = bisect.bisect_left(arr, x)
    if index < len(arr) and arr[index] == x:
        return index
    return -1

""""""
Fancy Binary Search
fancy-binsearch

Input:
    arr: A sorted list of ints
    x: A value to find

Output:
    The lowest index i such that arr[i] == x, or -1 if x not in arr

Example:
    >>> find_first_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
    2
""""""",,,
BaselineAware,find_first_in_sorted,PASS,"import bisect

def find_first_in_sorted(arr, x):
    index = bisect.bisect_left(arr, x)  # Find the insertion point for x in arr

    if index < len(arr) and arr[index] == x:
        return index
    return -1

""""""
Fancy Binary Search
fancy-binsearch

Input:
    arr: A sorted list of ints
    x: A value to find

Output:
    The lowest index i such that arr[i] == x, or -1 if x not in arr

Example:
    >>> find_first_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
    2
""""""",,,
BaselineNaive,find_first_in_sorted,PASS,"def find_first_in_sorted(arr, x):
    lo = 0
    hi = len(arr) - 1

    while lo <= hi:
        mid = (lo + hi) // 2

        if x == arr[mid] and (mid == 0 or x != arr[mid - 1]):
            return mid

        elif x <= arr[mid]:
            hi = mid - 1

        else:
            lo = mid + 1

    return -1


""""""
Fancy Binary Search
fancy-binsearch


Input:
    arr: A sorted list of ints
    x: A value to find

Output:
    The lowest index i such that arr[i] == x, or -1 if x not in arr

Example:
    >>> find_first_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
    2
""""""",,,
ArcaneAgent,find_in_sorted,PASS,"import bisect

def find_in_sorted(arr, x):
    index = bisect.bisect_left(arr, x)
    if index != len(arr) and arr[index] == x:
        return index
    return -1

""""""
Binary Search

Input:
    arr: A sorted list of ints
    x: A value to find

Output:
    An index i such that arr[i] == x, or -1 if x not in arr

Example:
    >>> find_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
    3
""""""",,,
BaselineAware,find_in_sorted,PASS,"import bisect

def find_in_sorted(arr, x):
    index = bisect.bisect_left(arr, x)
    if index != len(arr) and arr[index] == x:
        return index
    return -1

""""""
Binary Search

Input:
    arr: A sorted list of ints
    x: A value to find

Output:
    An index i such that arr[i] == x, or -1 if x not in arr

Example:
    >>> find_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
    3
""""""",,,
BaselineNaive,find_in_sorted,PASS,"def find_in_sorted(arr, x):
    def binsearch(start, end):
        if start >= end:
            return -1
        mid = start + (end - start) // 2
        if x < arr[mid]:
            return binsearch(start, mid)
        elif x > arr[mid]:
            return binsearch(mid + 1, end)
        else:
            return mid

    return binsearch(0, len(arr))",,,
ArcaneAgent,flatten,PASS,"def flatten(arr):
    def _flatten(sub_arr):
        for x in sub_arr:
            if isinstance(x, list):
                yield from _flatten(x)
            else:
                yield x

    return _flatten(arr)

# Example usage:
# list(flatten([[1, [], [2, 3]], [[4]], 5])) -> [1, 2, 3, 4, 5]

""""""
Flatten

Flattens a nested list data structure into a single list.

Input:
    arr: A list

Precondition:
    The input has no list containment cycles

Output:
    A generator for the input's non-list objects

Example:
    >>> list(flatten([[1, [], [2, 3]], [[4]], 5]))
    [1, 2, 3, 4, 5]
""""""",,,
BaselineAware,flatten,PASS,"def flatten(arr):
    for x in arr:
        if isinstance(x, list):
            for y in flatten(x):
                yield y
        else:
            yield x

# Example usage
if __name__ == ""__main__"":
    example = [[1, [], [2, 3]], [[4]], 5]
    print(list(flatten(example)))",,,
BaselineNaive,flatten,PASS,"def flatten(arr):
    for x in arr:
        if isinstance(x, list):
            for y in flatten(x):
                yield y
        else:
            yield x



""""""
Flatten

Flattens a nested list data structure into a single list.


Input:
    arr: A list

Precondition:
    The input has no list containment cycles

Output:
    A generator for the input's non-list objects

Example:
    >>> list(flatten([[1, [], [2, 3]], [[4]], 5]))
    [1, 2, 3, 4, 5]
""""""",,,
ArcaneAgent,gcd,PASS,"import math

def gcd(a, b):
    """"""Calculate the greatest common divisor of two nonnegative integers.""""""
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError(""Both a and b must be integers."")
    if a < 0 or b < 0:
        raise ValueError(""Both a and b must be nonnegative integers."")

    return math.gcd(a, b)

# Example usage:
# >>> gcd(35, 21)
# 7",,,
BaselineAware,gcd,PASS,"def gcd(a, b):
    if not (isinstance(a, int) and isinstance(b, int)):
        raise ValueError(""Both inputs must be integers."")
    if a < 0 or b < 0:
        raise ValueError(""Both inputs must be nonnegative integers."")
    if a == 0 and b == 0:
        raise ValueError(""At least one input must be non-zero."")
    
    while b != 0:
        a, b = b, a % b
    return a

# Example usage
if __name__ == ""__main__"":
    print(gcd(35, 21))  # Output: 7",,,
BaselineNaive,gcd,PASS,"def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)


""""""
Input:
    a: A nonnegative int
    b: A nonnegative int


Greatest Common Divisor

Precondition:
    isinstance(a, int) and isinstance(b, int)

Output:
    The greatest int that divides evenly into a and b

Example:
    >>> gcd(35, 21)
    7

""""""",,,
ArcaneAgent,get_factors,PASS,"def get_factors(n):
    def factorize(n):
        factors = []
        for i in range(2, int(n ** 0.5) + 1):
            while n % i == 0:
                factors.append(i)
                n //= i
        if n > 1:
            factors.append(n)
        return factors

    if n <= 1:
        return []

    return factorize(n)

# Examples
if __name__ == ""__main__"":
    print(get_factors(1))    # Output: []
    print(get_factors(100))  # Output: [2, 2, 5, 5]
    print(get_factors(101))  # Output: [101]",,,
BaselineAware,get_factors,PASS,"def get_factors_iterative(n):
    factors = []
    if n == 1:
        return factors

    for i in range(2, int(n ** 0.5) + 1):
        while n % i == 0:
            factors.append(i)
            n //= i

    if n > 1:
        factors.append(n)

    return factors


""""""
Prime Factorization

Factors an int using naive trial division.

Input:
    n: An int to factor

Output:
    A list of the prime factors of n in sorted order with repetition

Precondition:
    n >= 1

Examples:
    >>> get_factors_iterative(1)
    []
    >>> get_factors_iterative(100)
    [2, 2, 5, 5]
    >>> get_factors_iterative(101)
    [101]
""""""",,,
BaselineNaive,get_factors,PASS,"def get_factors(n):
    if n == 1:
        return []

    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return [i] + get_factors(n // i)

    return [n]

""""""
Prime Factorization

Factors an int using naive trial division.

Input:
    n: An int to factor

Output:
    A list of the prime factors of n in sorted order with repetition

Precondition:
    n >= 1

Examples:
    >>> get_factors(1)
    []
    >>> get_factors(100)
    [2, 2, 5, 5]
    >>> get_factors(101)
    [101]
""""""",,,
ArcaneAgent,hanoi,PASS,"from typing import List, Tuple, Dict

def get_auxiliary_peg(start: int, end: int) -> int:
    return 6 - start - end

memo: Dict[Tuple[int, int, int], List[Tuple[int, int]]] = {}

def hanoi(height: int, start: int = 1, end: int = 3) -> List[Tuple[int, int]]:
    if height == 0:
        return []
    
    if (height, start, end) in memo:
        return memo[(height, start, end)]
    
    auxiliary_peg = get_auxiliary_peg(start, end)
    steps = hanoi(height - 1, start, auxiliary_peg)
    steps.append((start, end))
    steps.extend(hanoi(height - 1, auxiliary_peg, end))
    
    memo[(height, start, end)] = steps
    return steps",,,
BaselineAware,hanoi,PASS,"from typing import List, Tuple
from functools import lru_cache

@lru_cache(maxsize=None)
def hanoi(height: int, start: int = 1, end: int = 3) -> List[Tuple[int, int]]:
    if height == 0:
        return []
    
    intermediate_peg = 6 - start - end
    return (
        hanoi(height - 1, start, intermediate_peg) +
        [(start, end)] +
        hanoi(height - 1, intermediate_peg, end)
    )

""""""
Towers of Hanoi
hanoi

An algorithm for solving the Towers of Hanoi puzzle. Three pegs exist, with a stack of differently-sized
disks beginning on one peg, ordered from smallest on top to largest on bottom. The goal is to move the
entire stack to a different peg via a series of steps. Each step must move a single disk from one peg to
another. At no point may a disk be placed on top of another smaller disk.

Input:
    height: The height of the initial stack of disks.
    start: The numbered peg where the initial stack resides.
    end: The numbered peg which the stack must be moved onto.

Preconditions:
    height >= 0
    start in (1, 2, 3)
    end in (1, 2, 3)

Output:
    An ordered list of pairs (a, b) representing the shortest series of steps (each step moving
    the top disk from peg a to peg b) that solves the puzzle.
""""""",,,
BaselineNaive,hanoi,PASS,"def hanoi(height, start=1, end=3):
    steps = []
    if height > 0:
        helper = ({1, 2, 3} - {start, end}).pop()
        steps.extend(hanoi(height - 1, start, helper))
        steps.append((start, end))
        steps.extend(hanoi(height - 1, helper, end))

    return steps


""""""
Towers of Hanoi
hanoi


An algorithm for solving the Towers of Hanoi puzzle.  Three pegs exist, with a stack of differently-sized
disks beginning on one peg, ordered from smallest on top to largest on bottom.  The goal is to move the
entire stack to a different peg via a series of steps.  Each step must move a single disk from one peg to
another. At no point may a disk be placed on top of another smaller disk.

Input:
    height: The height of the initial stack of disks.
    start: The numbered peg where the initial stack resides.
    end: The numbered peg which the stack must be moved onto.

Preconditions:
    height >= 0
    start in (1, 2, 3)
    end in (1, 2, 3)

Output:
    An ordered list of pairs (a, b) representing the shortest series of steps (each step moving
    the top disk from peg a to peg b) that solves the puzzle.
""""""",,,
ArcaneAgent,is_valid_parenthesization,PASS,"def is_valid_parenthesization(parens):
    """"""
    Determines if a string of parentheses is properly nested using a stack.

    Args:
        parens (str): A string consisting only of '(' and ')'.

    Returns:
        bool: True if the parentheses are properly nested, False otherwise.

    Raises:
        ValueError: If the input contains characters other than '(' and ')'.

    Examples:
        >>> is_valid_parenthesization('((()()))()')
        True
        >>> is_valid_parenthesization(')()(')
        False
    """"""
    if not all(paren in '()' for paren in parens):
        raise ValueError(""Input must only contain '(' and ')' characters."")

    stack = []
    for paren in parens:
        if paren == '(':
            stack.append(paren)
        else:
            if not stack:
                return False
            stack.pop()

    return not stack",,,
BaselineAware,is_valid_parenthesization,PASS,"def is_valid_parenthesization(parens):
    depth = 0
    for paren in parens:
        depth += 1 if paren == '(' else -1
        if depth < 0:
            return False

    return depth == 0


""""""
Nested Parens
Input:
    parens: A string of parentheses

Precondition:
    all(paren in '()' for paren in parens)

Output:
    Whether the parentheses are properly nested

Examples:
    >>> is_valid_parenthesization('((()()))()')
    True
    >>> is_valid_parenthesization(')()(')
    False
""""""",,,
BaselineNaive,is_valid_parenthesization,PASS,"def is_valid_parenthesization(parens):
    depth = 0
    for paren in parens:
        if paren == '(':
            depth += 1
        else:
            depth -= 1
            if depth < 0:
                return False

    return depth == 0


""""""
Nested Parens
Input:
    parens: A string of parentheses

Precondition:
    all(paren in '()' for paren in parens)

Output:
    Whether the parentheses are properly nested

Examples:
    >>> is_valid_parenthesization('((()()))()')
    True
    >>> is_valid_parenthesization(')()(')
    False
""""""",,,
ArcaneAgent,kheapsort,PASS,"import heapq
from typing import List, Generator

def kheapsort(arr: List[int], k: int) -> Generator[int, None, None]:
    """"""
    Sorts an almost-sorted array using a k-sized heap.

    Args:
        arr (List[int]): The list of integers to sort.
        k (int): The maximum displacement of an element from its sorted position.

    Yields:
        int: The next element in sorted order.

    Raises:
        ValueError: If k is negative or arr is not a list of unique integers.
    """"""
    if not isinstance(arr, list) or len(arr) != len(set(arr)):
        raise ValueError(""Input array must be a list of unique integers."")
    if k < 0:
        raise ValueError(""k must be a non-negative integer."")

    if k == 0:
        yield from arr
        return

    heap = arr[:k]
    heapq.heapify(heap)

    for x in arr[k:]:
        yield heapq.heappushpop(heap, x)

    while heap:
        yield heapq.heappop(heap)",,,
BaselineAware,kheapsort,PASS,"import heapq
from typing import List, Generator

def kheapsort(arr: List[int], k: int) -> Generator[int, None, None]:
    """"""
    K-Heapsort

    Sorts an almost-sorted array, wherein every element is no more than k units from its sorted position, in O(n log k) time.

    Parameters:
    - arr: List[int] - A list of unique integers.
    - k: int - Maximum displacement of an element in arr from its final sorted location.

    Returns:
    - Generator[int, None, None] - A generator yielding the elements of arr in sorted order.

    Raises:
    - ValueError: If the input array is empty or k is negative.

    Example:
    >>> list(kheapsort([3, 2, 1, 5, 4], 2))
    [1, 2, 3, 4, 5]
    """"""
    def initialize_heap(arr: List[int], k: int) -> List[int]:
        heap = arr[:min(k, len(arr))]
        heapq.heapify(heap)
        return heap

    if not arr or k < 0:
        raise ValueError(""Array must not be empty and k must be non-negative."")
    
    if k == 0:
        yield from arr
        return

    min_heap = initialize_heap(arr, k)

    for x in arr[k:]:
        yield heapq.heappushpop(min_heap, x)

    while min_heap:
        yield heapq.heappop(min_heap)",,,
BaselineNaive,kheapsort,PASS,"def kheapsort(arr, k):
    import heapq

    heap = arr[:k+1]
    heapq.heapify(heap)

    for x in arr[k+1:]:
        yield heapq.heappushpop(heap, x)

    while heap:
        yield heapq.heappop(heap)


""""""
K-Heapsort
k-heapsort

Sorts an almost-sorted array, wherein every element is no more than k units from its sorted position, in O(n log k) time.

Input:
    arr: A list of ints
    k: an int indicating the maximum displacement of an element in arr from its final sorted location

Preconditions:
    The elements of arr are unique.
    Each element in arr is at most k places from its sorted position.

Output:
    A generator that yields the elements of arr in sorted order

Example:
    >>> list(kheapsort([3, 2, 1, 5, 4], 2))
    [1, 2, 3, 4, 5]
    >>> list(kheapsort([5, 4, 3, 2, 1], 4))
    [1, 2, 3, 4, 5]
    >>> list(kheapsort([1, 2, 3, 4, 5], 0))
    [1, 2, 3, 4, 5]
""""""",,,
ArcaneAgent,knapsack,FAIL_TIMEOUT,,,,Test run exceeded 60-second timeout (potential infinite loop).
BaselineAware,knapsack,FAIL_TIMEOUT,,,,Test run exceeded 60-second timeout (potential infinite loop).
BaselineNaive,knapsack,FAIL_TIMEOUT,,,,Test run exceeded 60-second timeout (potential infinite loop).
ArcaneAgent,kth,PASS,"import random

def kth(arr, k):
    if len(arr) == 1:
        return arr[0]

    pivot_index = random.randint(0, len(arr) - 1)
    pivot = arr[pivot_index]

    below = [x for x in arr if x < pivot]
    above = [x for x in arr if x > pivot]

    num_less = len(below)
    num_lessoreq = len(arr) - len(above)

    if k < num_less:
        return kth(below, k)
    elif k >= num_lessoreq:
        return kth(above, k - num_lessoreq)
    else:
        return pivot

# Example usage:
# arr = [3, 1, 2, 4, 5]
# k = 2
# print(kth(arr, k))  # Output should be 3, the 3rd smallest element",,,
BaselineAware,kth,PASS,"def partition(arr, left, right, pivot_index):
    pivot_value = arr[pivot_index]
    arr[pivot_index], arr[right] = arr[right], arr[pivot_index]
    store_index = left

    for i in range(left, right):
        if arr[i] < pivot_value:
            arr[i], arr[store_index] = arr[store_index], arr[i]
            store_index += 1

    arr[store_index], arr[right] = arr[right], arr[store_index]
    return store_index

def kth(arr, k):
    left, right = 0, len(arr) - 1

    while left <= right:
        pivot_index = left
        pivot_index = partition(arr, left, right, pivot_index)

        if k == pivot_index:
            return arr[k]
        elif k < pivot_index:
            right = pivot_index - 1
        else:
            left = pivot_index + 1

    raise ValueError(""k is out of bounds"")

# Example usage:
if __name__ == ""__main__"":
    arr = [3, 1, 2, 4, 5]
    k = 2
    print(f""The {k}-th smallest element is: {kth(arr, k)}"")",,,
BaselineNaive,kth,PASS,"def kth(arr, k):
    pivot = arr[0]
    below = [x for x in arr if x < pivot]
    above = [x for x in arr if x > pivot]
    pivots = [x for x in arr if x == pivot]

    num_less = len(below)
    num_lessoreq = num_less + len(pivots)

    if k < num_less:
        return kth(below, k)
    elif k >= num_lessoreq:
        return kth(above, k - num_lessoreq)
    else:
        return pivot

""""""
QuickSelect

This is an efficient equivalent to sorted(arr)[k].

Input:
    arr: A list of ints
    k: An int

Precondition:
    0 <= k < len(arr)

Output:
    The kth-lowest element of arr (0-based)
""""""",,,
ArcaneAgent,lcs_length,PASS,"def lcs_length(s, t):
    if not s or not t:
        return 0

    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_length = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                max_length = max(max_length, dp[i][j])

    return max_length

# Example usage
if __name__ == ""__main__"":
    print(lcs_length('witch', 'sandwich'))  # Output: 2
    print(lcs_length('meow', 'homeowner'))  # Output: 4",,,
BaselineAware,lcs_length,PASS,"def lcs_length(s, t):
    if not s or not t:
        return 0

    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_length = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                max_length = max(max_length, dp[i][j])

    return max_length

# Example usage
if __name__ == ""__main__"":
    print(lcs_length('witch', 'sandwich'))  # Output: 2
    print(lcs_length('meow', 'homeowner'))  # Output: 4",,,
BaselineNaive,lcs_length,PASS,"def lcs_length(s, t):
    from collections import defaultdict

    dp = defaultdict(int)

    max_length = 0

    for i in range(len(s)):
        for j in range(len(t)):
            if s[i] == t[j]:
                if i == 0 or j == 0:
                    dp[i, j] = 1
                else:
                    dp[i, j] = dp[i - 1, j - 1] + 1
                max_length = max(max_length, dp[i, j])

    return max_length



""""""
Longest Common Substring
longest-common-substring

Input:
    s: a string
    t: a string

Output:
    Length of the longest substring common to s and t

Example:
    >>> lcs_length('witch', 'sandwich')
    2
    >>> lcs_length('meow', 'homeowner')
    4
""""""",,,
ArcaneAgent,levenshtein,FAIL_TIMEOUT,,,,Test run exceeded 60-second timeout (potential infinite loop).
BaselineAware,levenshtein,FAIL_TIMEOUT,,,,Test run exceeded 60-second timeout (potential infinite loop).
BaselineNaive,levenshtein,FAIL_TIMEOUT,,,,Test run exceeded 60-second timeout (potential infinite loop).
ArcaneAgent,lis,PASS,"import bisect

class LongestIncreasingSubsequence:
    def __init__(self, arr):
        self.arr = arr

    def calculate(self):
        if not self.arr:
            return 0

        subsequence_ends = []

        for value in self.arr:
            pos = bisect.bisect_left(subsequence_ends, value)
            if pos == len(subsequence_ends):
                subsequence_ends.append(value)
            else:
                subsequence_ends[pos] = value

        return len(subsequence_ends)

# Usage
def lis(arr):
    lis_calculator = LongestIncreasingSubsequence(arr)
    return lis_calculator.calculate()

""""""
Longest Increasing Subsequence
longest-increasing-subsequence

Input:
    arr: A sequence of ints

Precondition:
    The ints in arr are unique

Output:
    The length of the longest monotonically increasing subsequence of arr

Example:
    >>> lis([4, 1, 5, 3, 7, 6, 2])
    3
""""""",,,
BaselineAware,lis,PASS,"def lis(arr):
    if not arr:
        return 0

    from bisect import bisect_left

    dp = []

    for val in arr:
        pos = bisect_left(dp, val)
        if pos == len(dp):
            dp.append(val)
        else:
            dp[pos] = val

    return len(dp)

""""""
This approach uses a dynamic programming array `dp` to store the smallest possible tail value for all increasing subsequences of different lengths. The `bisect_left` function is used to find the position to replace or extend the `dp` array, ensuring the sequence remains increasing. This method has a time complexity of O(n log n).
""""""

# Example usage
if __name__ == ""__main__"":
    example_arr = [4, 1, 5, 3, 7, 6, 2]
    print(lis(example_arr))  # Output: 3",,,
BaselineNaive,lis,PASS,"def lis(arr):
    ends = {}
    longest = 0

    for i, val in enumerate(arr):
        prefix_lengths = [j for j in range(1, longest + 1) if arr[ends[j]] < val]

        length = max(prefix_lengths) if prefix_lengths else 0

        if length == longest or length + 1 not in ends or val < arr[ends[length + 1]]:
            ends[length + 1] = i
            longest = max(longest, length + 1)

    return longest

""""""
Longest Increasing Subsequence
longest-increasing-subsequence

Input:
    arr: A sequence of ints

Precondition:
    The ints in arr are unique

Output:
    The length of the longest monotonically increasing subsequence of arr

Example:
    >>> lis([4, 1, 5, 3, 7, 6, 2])
    3
""""""",,,
ArcaneAgent,longest_common_subsequence,PASS,"def longest_common_subsequence(a, b):
    if len(a) < len(b):
        a, b = b, a

    previous = [''] * (len(b) + 1)
    current = [''] * (len(b) + 1)

    for i in range(1, len(a) + 1):
        for j in range(1, len(b) + 1):
            if a[i - 1] == b[j - 1]:
                current[j] = previous[j - 1] + a[i - 1]
            else:
                current[j] = max(previous[j], current[j - 1], key=len)
        previous, current = current, previous

    return previous[len(b)]

# Example usage
if __name__ == ""__main__"":
    result = longest_common_subsequence('headache', 'pentadactyl')
    print(result)  # Output: 'eadac'",,,
BaselineAware,longest_common_subsequence,PASS,"def longest_common_subsequence(a, b):
    m, n = len(a), len(b)
    previous = [''] * (n + 1)
    current = [''] * (n + 1)

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if a[i - 1] == b[j - 1]:
                current[j] = previous[j - 1] + a[i - 1]
            else:
                current[j] = max(previous[j], current[j - 1], key=len)
        previous, current = current, [''] * (n + 1)

    return previous[n]

# Example usage
if __name__ == ""__main__"":
    result = longest_common_subsequence('headache', 'pentadactyl')
    print(result)  # Output: 'eadac'",,,
BaselineNaive,longest_common_subsequence,PASS,"def longest_common_subsequence(a, b):
    if not a or not b:
        return ''

    elif a[0] == b[0]:
        return a[0] + longest_common_subsequence(a[1:], b[1:])

    else:
        return max(
            longest_common_subsequence(a, b[1:]),
            longest_common_subsequence(a[1:], b),
            key=len
        )



""""""
Longest Common Subsequence


Calculates the longest subsequence common to the two input strings. (A subsequence is any sequence of letters in the same order
they appear in the string, possibly skipping letters in between.)

Input:
    a: The first string to consider.
    b: The second string to consider.

Output:
    The longest string which is a subsequence of both strings. (If multiple subsequences of equal length exist, either is OK.)

Example:
    >>> longest_common_subsequence('headache', 'pentadactyl')
    'eadac'
""""""",,,
ArcaneAgent,max_sublist_sum,PASS,"def max_sublist_sum(arr):
    if not arr:
        return 0  # Return 0 for an empty array

    max_ending_here = 0
    max_so_far = arr[0]  # Start with the first element

    for x in arr:
        max_ending_here = max_ending_here + x
        max_so_far = max(max_so_far, max_ending_here)
        if max_ending_here < 0:
            max_ending_here = 0

    return max_so_far


""""""
Max Sublist Sum
max-sublist-sum

Efficient equivalent to max(sum(arr[i:j]) for 0 <= i <= j <= len(arr))

Algorithm source: WordAligned.org by Thomas Guest


Input:
    arr: A list of ints

Output:
    The maximum sublist sum

Example:
    >>> max_sublist_sum([4, -5, 2, 1, -1, 3])
    5
""""""",,,
BaselineAware,max_sublist_sum,PASS,"def max_sublist_sum(arr):
    if not arr:
        return 0  # Handle empty array case

    max_ending_here = 0
    max_so_far = float('-inf')
    max_element = float('-inf')

    for x in arr:
        max_ending_here = max_ending_here + x
        max_so_far = max(max_so_far, max_ending_here)
        if max_ending_here < 0:
            max_ending_here = 0
        max_element = max(max_element, x)

    return max_so_far if max_so_far > 0 else max_element

# Example usage
if __name__ == ""__main__"":
    print(max_sublist_sum([4, -5, 2, 1, -1, 3]))  # Output: 5
    print(max_sublist_sum([-4, -5, -2, -1, -3]))  # Output: -1",,,
BaselineNaive,max_sublist_sum,PASS,"def max_sublist_sum(arr):
    max_ending_here = 0
    max_so_far = float('-inf')  # Initialize to negative infinity to handle all negative lists

    for x in arr:
        max_ending_here = max(x, max_ending_here + x)  # Start new sublist if current element is greater
        max_so_far = max(max_so_far, max_ending_here)

    return max_so_far


""""""
Max Sublist Sum
max-sublist-sum

Efficient equivalent to max(sum(arr[i:j]) for 0 <= i <= j <= len(arr))

Algorithm source: WordAligned.org by Thomas Guest


Input:
    arr: A list of ints

Output:
    The maximum sublist sum

Example:
    >>> max_sublist_sum([4, -5, 2, 1, -1, 3])
    5
""""""",,,
ArcaneAgent,mergesort,PASS,"from typing import List

class MergeSort:
    @staticmethod
    def merge(left: List[int], right: List[int]) -> List[int]:
        """"""Merge two sorted lists into a single sorted list.""""""
        result = []
        i = 0
        j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result.extend(left[i:] or right[j:])
        return result

    @staticmethod
    def sort(arr: List[int]) -> List[int]:
        """"""Sorts an array of integers using the merge sort algorithm.""""""
        if len(arr) < 2:
            return arr
        middle = len(arr) // 2
        left = MergeSort.sort(arr[:middle])
        right = MergeSort.sort(arr[middle:])
        return MergeSort.merge(left, right)

# Usage
if __name__ == ""__main__"":
    sorted_array = MergeSort.sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])
    print(sorted_array)",,,
BaselineAware,mergesort,PASS,"from typing import List

def merge(left: List[int], right: List[int]) -> List[int]:
    """"""
    Merges two sorted lists into a single sorted list.
    """"""
    result = []
    i = 0
    j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:] or right[j:])
    return result

def mergesort(arr: List[int]) -> List[int]:
    """"""
    Sorts a list of integers using the merge sort algorithm.
    """"""
    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):
        raise ValueError(""Input must be a list of integers"")

    if len(arr) <= 1:
        return arr

    middle = len(arr) // 2
    left = mergesort(arr[:middle])
    right = mergesort(arr[middle:])
    return merge(left, right)",,,
BaselineNaive,mergesort,PASS,"def mergesort(arr):
    def merge(left, right):
        result = []
        i = 0
        j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result.extend(left[i:])
        result.extend(right[j:])
        return result

    if len(arr) <= 1:
        return arr
    else:
        middle = len(arr) // 2
        left = mergesort(arr[:middle])
        right = mergesort(arr[middle:])
        return merge(left, right)

""""""
Merge Sort

Input:
    arr: A list of ints

Output:
    The elements of arr in sorted order
""""""",,,
ArcaneAgent,next_palindrome,PASS,"def next_palindrome(digit_list):
    def increment_and_mirror(digits, left, right):
        if left < 0:
            return [1] + [0] * (len(digits) - 1) + [1]
        
        if digits[left] < 9:
            digits[left] += 1
            if left != right:
                digits[right] += 1
            return digits
        
        digits[left] = 0
        digits[right] = 0
        return increment_and_mirror(digits, left - 1, right + 1)
    
    n = len(digit_list)
    digit_list = increment_and_mirror(digit_list, (n - 1) // 2, n // 2)
    
    # Mirror the left to right
    for i in range((n + 1) // 2):
        digit_list[n - 1 - i] = digit_list[i]
    
    return digit_list

# Example usage
if __name__ == ""__main__"":
    example = [1, 4, 9, 4, 1]
    print(next_palindrome(example))  # Output: [1, 5, 0, 5, 1]",,,
BaselineAware,next_palindrome,PASS,"def increment_with_carry(digits):
    for i in range(len(digits) - 1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0
    return [1] + digits

def next_palindrome(digit_list):
    n = len(digit_list)
    if all(d == 9 for d in digit_list):
        return [1] + [0] * (n - 1) + [1]

    mid = n // 2
    left = digit_list[:mid]
    if n % 2 == 0:
        right = digit_list[mid:]
    else:
        right = digit_list[mid+1:]

    new_palindrome = left + digit_list[mid:mid+1] + left[::-1]
    if new_palindrome > digit_list:
        return new_palindrome

    left = increment_with_carry(left)
    return left + digit_list[mid:mid+1] + left[::-1]

# Example usage
if __name__ == ""__main__"":
    print(next_palindrome([1, 4, 9, 4, 1]))  # Output: [1, 5, 0, 5, 1]",,,
BaselineNaive,next_palindrome,PASS,"def next_palindrome(digit_list):
    high_mid = len(digit_list) // 2
    low_mid = (len(digit_list) - 1) // 2
    while high_mid < len(digit_list) and low_mid >= 0:
        if digit_list[high_mid] == 9:
            digit_list[high_mid] = 0
            digit_list[low_mid] = 0
            high_mid += 1
            low_mid -= 1
        else:
            digit_list[high_mid] += 1
            if low_mid != high_mid:
                digit_list[low_mid] += 1
            return digit_list
    return [1] + (len(digit_list) - 1) * [0] + [1]",,,
ArcaneAgent,next_permutation,PASS,"def swap_and_reverse(perm, i, j):
    perm[i], perm[j] = perm[j], perm[i]
    perm[i + 1:] = reversed(perm[i + 1:])
    return perm

def next_permutation(perm):
    for i in range(len(perm) - 2, -1, -1):
        if perm[i] < perm[i + 1]:
            for j in range(len(perm) - 1, i, -1):
                if perm[j] > perm[i]:
                    next_perm = list(perm)
                    return swap_and_reverse(next_perm, i, j)

# Example usage
if __name__ == ""__main__"":
    example_perm = [3, 2, 4, 1]
    print(next_permutation(example_perm))  # Output: [3, 4, 1, 2]",,,
BaselineAware,next_permutation,PASS,"def next_permutation(perm):
    """"""
    Generate the lexicographically next permutation of a list of unique integers.

    :param perm: List[int] - A list of unique integers
    :return: List[int] - The next permutation
    """"""
    assert perm == sorted(perm) or perm != sorted(perm, reverse=True), ""Precondition violated: perm is sorted in reverse order""

    # Convert to a list to allow modifications
    perm = list(perm)

    # Find the first decreasing element from the end
    for i in range(len(perm) - 2, -1, -1):
        if perm[i] < perm[i + 1]:
            # Find the element just larger than perm[i] to swap with
            for j in range(len(perm) - 1, i, -1):
                if perm[j] > perm[i]:
                    # Swap and reverse the suffix
                    perm[i], perm[j] = perm[j], perm[i]
                    return perm[:i + 1] + list(reversed(perm[i + 1:]))
    return perm

# Example usage
if __name__ == ""__main__"":
    example_perm = [3, 2, 4, 1]
    print(""Next permutation of"", example_perm, ""is"", next_permutation(example_perm))",,,
BaselineNaive,next_permutation,PASS,"def next_permutation(perm):
    for i in range(len(perm) - 2, -1, -1):
        if perm[i] < perm[i + 1]:
            for j in range(len(perm) - 1, i, -1):
                if perm[j] > perm[i]:
                    next_perm = list(perm)
                    next_perm[i], next_perm[j] = perm[j], perm[i]
                    next_perm[i + 1:] = reversed(next_perm[i + 1:])
                    return next_perm",,,
ArcaneAgent,pascal,PASS,"from functools import lru_cache

@lru_cache(maxsize=None)
def pascal(n):
    if n == 1:
        return [[1]]
    
    rows = pascal(n - 1)
    last_row = rows[-1]
    new_row = [1] + [last_row[c - 1] + last_row[c] for c in range(1, n - 1)] + [1]
    return rows + [new_row]

""""""
Pascal's Triangle
pascal

Input:
    n: The number of rows to return

Precondition:
    n >= 1

Output:
    The first n rows of Pascal's triangle as a list of n lists

Example:
    >>> pascal(5)
    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
""""""",,,
BaselineAware,pascal,PASS,"def pascal(n):
    def build_row(previous_row):
        return [1] + [previous_row[i] + previous_row[i + 1] for i in range(len(previous_row) - 1)] + [1]

    rows = [[1]]
    for _ in range(1, n):
        rows.append(build_row(rows[-1]))
    return rows

""""""
Pascal's Triangle
pascal

Input:
    n: The number of rows to return

Precondition:
    n >= 1

Output:
    The first n rows of Pascal's triangle as a list of n lists

Example:
    >>> pascal(5)
    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
""""""",,,
BaselineNaive,pascal,PASS,"def pascal(n):
    rows = [[1]]
    for r in range(1, n):
        row = [1]  # Start each row with a 1
        for c in range(1, r):
            upleft = rows[r - 1][c - 1]
            upright = rows[r - 1][c]
            row.append(upleft + upright)
        row.append(1)  # End each row with a 1
        rows.append(row)

    return rows


""""""
Pascal's Triangle
pascal

Input:
    n: The number of rows to return

Precondition:
    n >= 1

Output:
    The first n rows of Pascal's triangle as a list of n lists

Example:
    >>> pascal(5)
    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
""""""",,,
ArcaneAgent,possible_change,PASS,"def possible_change(coins, total):
    dp = [0] * (total + 1)
    dp[0] = 1  # Base case: one way to make change for 0

    for coin in coins:
        for amount in range(coin, total + 1):
            dp[amount] += dp[amount - coin]

    return dp[total]

# Example usage:
if __name__ == ""__main__"":
    print(possible_change([1, 5, 10, 25], 11))  # Output: 4",,,
BaselineAware,possible_change,PASS,"def possible_change(coins, total):
    if not isinstance(coins, list) or not all(isinstance(c, int) and c > 0 for c in coins):
        raise ValueError(""Coins must be a list of positive integers."")
    if not isinstance(total, int) or total < 0:
        raise ValueError(""Total must be a non-negative integer."")

    dp = [0] * (total + 1)
    dp[0] = 1  # Base case: one way to make change for 0

    for coin in coins:
        for amount in range(coin, total + 1):
            dp[amount] += dp[amount - coin]

    return dp[total]

# Example usage
if __name__ == ""__main__"":
    print(possible_change([1, 5, 10, 25], 11))  # Output: 4",,,
BaselineNaive,possible_change,PASS,"# Python 3
def possible_change(coins, total):
    if total == 0:
        return 1
    if total < 0:
        return 0
    if not coins:
        return 0

    first, *rest = coins
    return possible_change(coins, total - first) + possible_change(rest, total)



""""""
Making Change
change


Input:
    coins: A list of positive ints representing coin denominations
    total: An int value to make change for

Output:
    The number of distinct ways to make change adding up to total using only coins of the given values.
    For example, there are exactly four distinct ways to make change for the value 11 using coins [1, 5, 10, 25]:
        1. {1: 11, 5: 0, 10: 0, 25: 0}
        2. {1: 6, 5: 1, 10: 0, 25: 0}
        3. {1: 1, 5: 2, 10: 0, 25: 0}
        4. {1: 1, 5: 0, 10: 1, 25: 0}

Example:
    >>> possible_change([1, 5, 10, 25], 11)
    4
""""""",,,
ArcaneAgent,powerset,PASS,"from itertools import chain, combinations

def powerset(arr):
    return list(chain.from_iterable(combinations(arr, r) for r in range(len(arr) + 1)))

# Example usage:
if __name__ == ""__main__"":
    print(powerset(['a', 'b', 'c']))",,,
BaselineAware,powerset,PASS,"from itertools import chain, combinations

def powerset(arr):
    return list(chain.from_iterable(combinations(arr, r) for r in range(len(arr) + 1)))

""""""
Power Set

Input:
    arr: A list

Precondition:
    arr has no duplicate elements

Output:
    A list of lists, each representing a different subset of arr. The empty set is always a subset of arr, and arr is always a subset of arr.

Example:
    >>> powerset(['a', 'b', 'c'])
    [(), ('a',), ('b',), ('a', 'b'), ('c',), ('a', 'c'), ('b', 'c'), ('a', 'b', 'c')]
""""""",,,
BaselineNaive,powerset,PASS,"def powerset(arr):
    if arr:
        first, *rest = arr
        rest_subsets = powerset(rest)
        return rest_subsets + [[first] + subset for subset in rest_subsets]
    else:
        return [[]]


""""""
Power Set

Input:
    arr: A list

Precondition:
    arr has no duplicate elements

Output:
    A list of lists, each representing a different subset of arr. The empty set is always a subset of arr, and arr is always a subset of arr.

Example:
    >>> powerset(['a', 'b', 'c'])
    [[], ['c'], ['b'], ['b', 'c'], ['a'], ['a', 'c'], ['a', 'b'], ['a', 'b', 'c']]
""""""",,,
ArcaneAgent,quicksort,PASS,"def quicksort(arr):
    def partition(low, high):
        pivot = arr[high]
        i = low - 1
        for j in range(low, high):
            if arr[j] < pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1

    def quicksort_helper(low, high):
        while low < high:
            pivot_index = partition(low, high)
            if pivot_index - low < high - pivot_index:
                quicksort_helper(low, pivot_index - 1)
                low = pivot_index + 1
            else:
                quicksort_helper(pivot_index + 1, high)
                high = pivot_index - 1

    quicksort_helper(0, len(arr) - 1)
    return arr

# Example usage
if __name__ == ""__main__"":
    arr = [3, 6, 8, 10, 1, 2, 1]
    print(""Original array:"", arr)
    sorted_arr = quicksort(arr)
    print(""Sorted array:"", sorted_arr)",,,
BaselineAware,quicksort,PASS,"def quicksort_median_of_three(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1

    if low < high:
        pivot_index = median_of_three_partition(arr, low, high)
        quicksort_median_of_three(arr, low, pivot_index - 1)
        quicksort_median_of_three(arr, pivot_index + 1, high)

def median_of_three_partition(arr, low, high):
    mid = (low + high) // 2
    pivot_candidates = [(arr[low], low), (arr[mid], mid), (arr[high], high)]
    pivot_candidates.sort(key=lambda x: x[0])
    pivot_value, pivot_index = pivot_candidates[1]
    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]
    return partition(arr, low, high)

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Example usage
if __name__ == ""__main__"":
    arr = [3, 6, 8, 10, 1, 2, 1]
    quicksort_median_of_three(arr)
    print(""Sorted array:"", arr)",,,
BaselineNaive,quicksort,PASS,"def quicksort(arr):
    if not arr:
        return []

    pivot = arr[0]
    lesser = quicksort([x for x in arr[1:] if x <= pivot])
    greater = quicksort([x for x in arr[1:] if x > pivot])
    return lesser + [pivot] + greater

""""""
QuickSort


Input:
    arr: A list of ints

Output:
    The elements of arr in sorted order
""""""",,,
ArcaneAgent,rpn_eval,PASS,"from typing import List, Union

def perform_operation(stack: List[float], operator: str) -> None:
    if len(stack) < 2:
        raise ValueError(""Insufficient values in the expression"")
    b = stack.pop()
    a = stack.pop()
    operations = {
        '+': a + b,
        '-': a - b,
        '*': a * b,
        '/': a / b if b != 0 else float('inf')
    }
    if operator not in operations:
        raise ValueError(f""Invalid operator: {operator}"")
    stack.append(operations[operator])

def rpn_eval(tokens: List[Union[float, str]]) -> float:
    stack: List[float] = []

    for token in tokens:
        if isinstance(token, float):
            stack.append(token)
        elif token in ('+', '-', '*', '/'):
            perform_operation(stack, token)
        else:
            raise TypeError(f""Invalid token type: {token}"")

    if len(stack) != 1:
        raise ValueError(""The user input has too many values"")

    return stack.pop()

# Example usage
if __name__ == ""__main__"":
    example_tokens = [3.0, 5.0, '+', 2.0, '/']
    result = rpn_eval(example_tokens)
    print(f""Result of RPN evaluation: {result}"")",,,
BaselineAware,rpn_eval,PASS,"from typing import List, Union

class RPNCalculator:
    def __init__(self):
        self.stack: List[float] = []

    def evaluate(self, tokens: List[Union[float, str]]) -> float:
        if not tokens or len(tokens) < 3:
            raise ValueError(""Insufficient tokens for RPN evaluation"")

        for token in tokens:
            if isinstance(token, float):
                self.stack.append(token)
            else:
                self._apply_operation(token)

        if len(self.stack) != 1:
            raise ValueError(""The input tokens do not form a valid RPN expression"")

        return self.stack.pop()

    def _apply_operation(self, symbol: str):
        if len(self.stack) < 2:
            raise ValueError(""Insufficient operands for the operation"")
        operand2 = self.stack.pop()
        operand1 = self.stack.pop()
        result = self._operation(symbol, operand1, operand2)
        self.stack.append(result)

    def _operation(self, symbol: str, operand1: float, operand2: float) -> float:
        operations = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y if y != 0 else float('inf')  # Handle division by zero
        }
        return operations[symbol](operand1, operand2)

# Usage
calculator = RPNCalculator()
result = calculator.evaluate([3.0, 5.0, '+', 2.0, '/'])
print(result)",,,
BaselineNaive,rpn_eval,PASS,"def rpn_eval(tokens):
    def op(symbol, a, b):
        return {
            '+': lambda a, b: a + b,
            '-': lambda a, b: a - b,
            '*': lambda a, b: a * b,
            '/': lambda a, b: a / b
        }[symbol](a, b)

    stack = []

    for token in tokens:
        if isinstance(token, float):
            stack.append(token)
        else:
            b = stack.pop()  # Corrected the order of popping
            a = stack.pop()
            stack.append(
                op(token, a, b)
            )

    return stack.pop()",,,
ArcaneAgent,shunting_yard,PASS,"def is_operator(token):
    """"""Check if the token is a valid operator.""""""
    return token in '+-*/'

def get_precedence(token):
    """"""Return the precedence and associativity of the operator.""""""
    precedence = {
        '+': (1, 'L'),
        '-': (1, 'L'),
        '*': (2, 'L'),
        '/': (2, 'L')
    }
    return precedence.get(token, (0, 'L'))

def shunting_yard(tokens):
    """"""
    Convert infix notation to Reverse Polish Notation using the shunting-yard algorithm.

    Parameters:
    tokens (list): A list of tokens in infix notation.

    Returns:
    list: The input tokens reordered into Reverse Polish Notation.

    Raises:
    ValueError: If an invalid token is encountered.
    """"""
    rpntokens = []
    opstack = []

    for token in tokens:
        if isinstance(token, int):
            rpntokens.append(token)
        elif is_operator(token):
            while (opstack and
                   (get_precedence(token)[0] < get_precedence(opstack[-1])[0] or
                    (get_precedence(token)[0] == get_precedence(opstack[-1])[0] and get_precedence(token)[1] == 'L'))):
                rpntokens.append(opstack.pop())
            opstack.append(token)
        else:
            raise ValueError(f""Invalid token: {token}"")

    while opstack:
        rpntokens.append(opstack.pop())

    return rpntokens

# Example usage
if __name__ == ""__main__"":
    print(shunting_yard([10, '-', 5, '-', 2]))  # Output: [10, 5, '-', 2, '-']
    print(shunting_yard([34, '-', 12, '/', 5]))  # Output: [34, 12, 5, '/', '-']
    print(shunting_yard([4, '+', 9, '*', 9, '-', 10, '+', 13]))  # Output: [4, 9, 9, '*', '+', 10, '-', 13, '+']",,,
BaselineAware,shunting_yard,PASS,"def is_operator(token):
    """"""Check if the token is a valid operator.""""""
    return token in '+-*/'

def get_precedence_and_associativity(op):
    """"""Return the precedence and associativity of an operator.""""""
    precedence = {
        '+': (1, 'L'),
        '-': (1, 'L'),
        '*': (2, 'L'),
        '/': (2, 'L')
    }
    return precedence.get(op, (0, 'L'))

def shunting_yard(tokens):
    """"""
    Convert infix notation to Reverse Polish Notation using the shunting-yard algorithm.

    :param tokens: A list of tokens in infix notation
    :return: A list of tokens in Reverse Polish Notation
    :raises ValueError: If an invalid token is encountered
    """"""
    rpntokens = []
    opstack = []

    for token in tokens:
        if isinstance(token, int):
            rpntokens.append(token)
        elif is_operator(token):
            while opstack:
                top_op = opstack[-1]
                token_prec, token_assoc = get_precedence_and_associativity(token)
                top_prec, _ = get_precedence_and_associativity(top_op)
                if token_prec < top_prec or (token_prec == top_prec and token_assoc == 'L'):
                    rpntokens.append(opstack.pop())
                else:
                    break
            opstack.append(token)
        else:
            raise ValueError(f""Invalid token: {token}"")

    while opstack:
        rpntokens.append(opstack.pop())

    return rpntokens

# Example usage
if __name__ == ""__main__"":
    examples = [
        ([10, '-', 5, '-', 2], [10, 5, '-', 2, '-']),
        ([34, '-', 12, '/', 5], [34, 12, 5, '/', '-']),
        ([4, '+', 9, '*', 9, '-', 10, '+', 13], [4, 9, 9, '*', '+', 10, '-', 13, '+'])
    ]

    for infix, expected in examples:
        result = shunting_yard(infix)
        assert result == expected, f""Expected {expected}, got {result}""
        print(f""Infix: {infix} -> RPN: {result}"")",,,
BaselineNaive,shunting_yard,PASS,"def shunting_yard(tokens):
    precedence = {
        '+': 1,
        '-': 1,
        '*': 2,
        '/': 2
    }

    rpntokens = []
    opstack = []
    for token in tokens:
        if isinstance(token, int):
            rpntokens.append(token)
        else:
            while opstack and precedence[token] <= precedence[opstack[-1]]:
                rpntokens.append(opstack.pop())
            opstack.append(token)

    while opstack:
        rpntokens.append(opstack.pop())

    return rpntokens


""""""
Infix to RPN Conversion
shunting-yard


Uses Dijkstra's shunting-yard algorithm to transform infix notation into equivalent Reverse Polish Notation.

Input:
    tokens: A list of tokens in infix notation

Precondition:
    all(isinstance(token, int) or token in '+-*/' for token in tokens)

Output:
    The input tokens reordered into Reverse Polish Notation

Examples:
    >>> shunting_yard([10, '-', 5, '-', 2])
    [10, 5, '-', 2, '-']
    >>> shunting_yard([34, '-', 12, '/', 5])
    [34, 12, 5, '/' ,'-']
    >>> shunting_yard([4, '+', 9, '*', 9, '-', 10, '+', 13])
    [4, 9, 9, '*', '+', 10, '-', 13, '+']
""""""",,,
ArcaneAgent,sieve,PASS,"def sieve(max):
    if max < 2:
        return []

    is_prime = [True] * (max + 1)
    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers

    for start in range(2, int(max**0.5) + 1):
        if is_prime[start]:
            for multiple in range(start*start, max + 1, start):
                is_prime[multiple] = False

    return [num for num, prime in enumerate(is_prime) if prime]

# Example usage:
# primes_up_to_30 = sieve(30)
# print(primes_up_to_30)  # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]",,,
BaselineAware,sieve,PASS,"from sympy import primerange

def sieve(max_value):
    """"""
    Sieve of Eratosthenes using a third-party library.

    Input:
        max_value: A positive int representing an upper bound.

    Output:
        A list containing all primes up to and including max_value.
    """"""
    return list(primerange(2, max_value + 1))

# Example usage
if __name__ == ""__main__"":
    max_value = 30
    print(f""Primes up to {max_value}: {sieve(max_value)}"")",,,
BaselineNaive,sieve,PASS,"def sieve(max):
    primes = []
    for n in range(2, max + 1):
        if all(n % p > 0 for p in primes):
            primes.append(n)
    return primes

""""""
Sieve of Eratosthenes
prime-sieve

Input:
    max: A positive int representing an upper bound.

Output:
    A list containing all primes up to and including max
""""""",,,
ArcaneAgent,sqrt,PASS,"def newton_raphson_sqrt(number, tolerance, max_iterations=1000):
    """"""
    Calculate the square root of a number using the Newton-Raphson method.

    Input:
        number: A float, the number to find the square root of.
        tolerance: A float, the acceptable error margin.
        max_iterations: An integer, the maximum number of iterations to perform.

    Precondition:
        number >= 1 and tolerance > 0

    Output:
        A float in the interval [sqrt(number) - tolerance, sqrt(number) + tolerance]

    Example:
        >>> newton_raphson_sqrt(2, 0.01)
        1.4142156862745097
    """"""
    approximation = number / 2
    iteration = 0
    while abs(approximation**2 - number) > tolerance and iteration < max_iterations:
        approximation = 0.5 * (approximation + number / approximation)
        iteration += 1
    return approximation",,,
BaselineAware,sqrt,PASS,"def sqrt(number, tolerance):
    """"""
    Calculate the square root of a number using the Newton-Raphson method.

    Args:
        number (float): The number to find the square root of. Must be >= 1.
        tolerance (float): The acceptable error margin. Must be > 0.

    Returns:
        float: An approximation of the square root within the specified tolerance.

    Raises:
        TypeError: If inputs are not numbers.
        ValueError: If preconditions are not met.
    """"""
    if not isinstance(number, (int, float)) or not isinstance(tolerance, (int, float)):
        raise TypeError(""Both number and tolerance must be numbers."")
    if number < 1:
        raise ValueError(""number must be greater than or equal to 1."")
    if tolerance <= 0:
        raise ValueError(""tolerance must be greater than 0."")

    # Use a better initial guess
    approximation = number / 2 if number < 4 else number / 4
    while abs(number - approximation**2) > tolerance:
        approximation = 0.5 * (approximation + number / approximation)
    return approximation",,,
BaselineNaive,sqrt,PASS,"def sqrt(x, epsilon):
    approx = x / 2
    while abs(x - approx**2) > epsilon:
        approx = 0.5 * (approx + x / approx)
    return approx

""""""
Square Root

Newton-Raphson method implementation.

Input:
    x: A float
    epsilon: A float

Precondition:
    x >= 1 and epsilon > 0

Output:
    A float in the interval [sqrt(x) - epsilon, sqrt(x) + epsilon]

Example:
    >>> sqrt(2, 0.01)
    1.4166666666666665
""""""",,,
ArcaneAgent,subsequences,PASS,"from itertools import combinations
from typing import List

def subsequences(start: int, end: int, length: int) -> List[List[int]]:
    if length < 0:
        raise ValueError(""Length must be a non-negative integer."")
    if start > end:
        raise ValueError(""Start must be less than or equal to end."")
    if length > (end - start + 1):
        return []  # No valid subsequences if length is greater than the range

    return [list(comb) for comb in combinations(range(start, end + 1), length)]

# Example usage
if __name__ == ""__main__"":
    print(subsequences(1, 5, 3))",,,
BaselineAware,subsequences,PASS,"from itertools import combinations
from typing import List

def subsequences(start: int, end: int, length: int) -> List[List[int]]:
    if length < 0:
        raise ValueError(""Length must be a non-negative integer."")
    if start > end:
        raise ValueError(""Start must be less than or equal to end."")
    if length > (end - start + 1):
        return []  # No valid subsequences possible

    return [list(comb) for comb in combinations(range(start, end + 1), length)]

# Example usage
if __name__ == ""__main__"":
    example_result = subsequences(start=1, end=5, length=3)
    print(example_result)  # Output: [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]",,,
BaselineNaive,subsequences,PASS,"def subsequences(a, b, k):
    if k == 0:
        return [[]]  # Return a list containing an empty list

    ret = []
    for i in range(a, b + 1 - k):
        ret.extend(
            [[i] + rest for rest in subsequences(i + 1, b, k - 1)]
        )

    return ret


""""""
Subsequences


Input:
    a: An int
    b: An int
    k: A positive int

Output:
    A list of all length-k ascending sequences of ints in range(a, b)

Example:
    >>> subsequences(a=1, b=5, k=3)
    [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]
""""""",,,
ArcaneAgent,to_base,PASS,"import string

def to_base(num, b):
    if not (isinstance(num, int) and num > 0):
        raise ValueError(""num must be a positive integer."")
    if not (isinstance(b, int) and 2 <= b <= 36):
        raise ValueError(""b must be an integer between 2 and 36."")
    
    alphabet = string.digits + string.ascii_uppercase
    result = []
    
    while num > 0:
        i = num % b
        num = num // b
        result.append(alphabet[i])
    
    return ''.join(reversed(result))",,,
BaselineAware,to_base,PASS,"import string

def to_base(num, b):
    if not isinstance(num, int) or not isinstance(b, int):
        raise TypeError(""Both num and b must be integers."")
    if num <= 0:
        raise ValueError(""num must be greater than 0."")
    if not (2 <= b <= 36):
        raise ValueError(""b must be between 2 and 36, inclusive."")

    alphabet = string.digits + string.ascii_uppercase
    result = []
    while num > 0:
        i = num % b
        num = num // b
        result.append(alphabet[i])
    return ''.join(reversed(result))

# Example usage
if __name__ == ""__main__"":
    print(to_base(31, 16))  # Output: '1F'",,,
BaselineNaive,to_base,PASS,"import string

def to_base(num, b):
    result = ''
    alphabet = string.digits + string.ascii_uppercase
    while num > 0:
        i = num % b
        num = num // b
        result = alphabet[i] + result  # Prepend the character to the result
    return result",,,
ArcaneAgent,wrap,PASS,"import textwrap

def wrap(text, cols):
    if cols <= 0:
        raise ValueError(""Column width must be greater than 0."")

    return textwrap.wrap(text, width=cols, expand_tabs=False, replace_whitespace=False, drop_whitespace=False)

""""""
Wrap Text

Given a long string and a column width, break the string on spaces into a list of lines such that each line is no longer than the column width.

Input:
    text: The starting text.
    cols: The target column width, i.e. the maximum length of any single line after wrapping.

Precondition:
    cols > 0.

Output:
    An ordered list of strings, each no longer than the column width, such that the concatenation of the strings returns the original text,
and such that no word in the original text is broken into two parts unless necessary.  The original amount of spaces are preserved (e.g. spaces
at the start or end of each line aren't trimmed.),Wrapping Text
""""""",,,
BaselineAware,wrap,PASS,"import textwrap

def wrap(text, cols):
    if cols <= 0:
        raise ValueError(""Column width must be greater than 0."")

    # Use textwrap to wrap the text while preserving spaces
    lines = textwrap.wrap(text, width=cols, break_long_words=False, replace_whitespace=False)

    return lines

# Example usage
if __name__ == ""__main__"":
    sample_text = ""This is a sample text that needs to be wrapped according to the specified column width.""
    column_width = 20
    wrapped_lines = wrap(sample_text, column_width)
    for line in wrapped_lines:
        print(repr(line))",,,
BaselineNaive,wrap,PASS,"def wrap(text, cols):
    lines = []
    while len(text) > cols:
        end = text.rfind(' ', 0, cols + 1)
        if end == -1:
            end = cols
        line, text = text[:end], text[end:].lstrip()
        lines.append(line)
    lines.append(text)  # Add the remaining text as the last line
    return lines

""""""
Wrap Text

Given a long string and a column width, break the string on spaces into a list of lines such that each line is no longer than the column width.

Input:
    text: The starting text.
    cols: The target column width, i.e. the maximum length of any single line after wrapping.

Precondition:
    cols > 0.

Output:
    An ordered list of strings, each no longer than the column width, such that the concatenation of the strings returns the original text,
and such that no word in the original text is broken into two parts unless necessary.  The original amount of spaces are preserved (e.g. spaces
at the start or end of each line aren't trimmed.),Wrapping Text
""""""",,,
